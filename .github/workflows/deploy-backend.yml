name: Deploy Backend to AWS ECS

on:
  push:
    branches: [main]
    paths:
      - "src/**"
      - "aws/task-definition.json"
      - ".github/workflows/deploy-backend.yml"
  workflow_dispatch:

concurrency:
  group: deploy-backend-${{ github.ref }}
  cancel-in-progress: true

env:
  AWS_REGION: ${{ vars.AWS_REGION || secrets.AWS_REGION || 'us-west-1' }}
  ECR_REPOSITORY: itg-backend
  ECS_CLUSTER: itg-backend-cluster
  ECS_SERVICE: itg-backend-service
  ECS_TASK_DEFINITION: aws/task-definition.json
  CONTAINER_NAME: itg-backend

jobs:
  deploy:
    name: Build & Deploy Backend
    runs-on: ubuntu-latest
    timeout-minutes: 45
    environment:
      name: AWS ECS - Prod
      url: https://d1kms8dniv7dqs.cloudfront.net

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build, tag, and push Docker image to ECR
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG -t $ECR_REGISTRY/$ECR_REPOSITORY:latest src/
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: Validate required deployment configuration
        env:
          DJANGO_SECRET_KEY: ${{ vars.DJANGO_SECRET_KEY || secrets.DJANGO_SECRET_KEY }}
          DB_HOST: ${{ vars.DB_HOST }}
          DB_NAME: ${{ vars.DB_NAME }}
          DB_USER: ${{ vars.DB_USER }}
          DB_PASSWORD: ${{ vars.DB_PASSWORD || secrets.DB_PASSWORD }}
        run: |
          missing=()
          for name in DJANGO_SECRET_KEY DB_HOST DB_NAME DB_USER DB_PASSWORD; do
            if [ -z "${!name}" ]; then
              missing+=("$name")
            fi
          done
          if [ "${#missing[@]}" -gt 0 ]; then
            echo "Missing required config: ${missing[*]}"
            exit 1
          fi

      - name: Render ECS task definition from template
        id: task-def
        env:
          IMAGE_URI: ${{ steps.build-image.outputs.image }}
          DJANGO_SECRET_KEY: ${{ vars.DJANGO_SECRET_KEY || secrets.DJANGO_SECRET_KEY }}
          DB_ENGINE: ${{ vars.DB_ENGINE }}
          DB_NAME: ${{ vars.DB_NAME }}
          DB_USER: ${{ vars.DB_USER }}
          DB_PASSWORD: ${{ vars.DB_PASSWORD || secrets.DB_PASSWORD }}
          DB_HOST: ${{ vars.DB_HOST }}
          DB_PORT: ${{ vars.DB_PORT }}
          REDIS_URL: ${{ vars.REDIS_URL || secrets.REDIS_URL }}
          DJANGO_SUPERUSER_USERNAME: ${{ vars.DJANGO_SUPERUSER_USERNAME || secrets.DJANGO_SUPERUSER_USERNAME }}
          DJANGO_SUPERUSER_EMAIL: ${{ vars.DJANGO_SUPERUSER_EMAIL || secrets.DJANGO_SUPERUSER_EMAIL }}
          DJANGO_SUPERUSER_PASSWORD: ${{ vars.DJANGO_SUPERUSER_PASSWORD || secrets.DJANGO_SUPERUSER_PASSWORD }}
          FRONTEND_URL: ${{ vars.FRONTEND_URL || 'https://main.d1fekd6ba7zdu.amplifyapp.com' }}
          API_BASE_URL: ${{ vars.VITE_API_BASE_URL }}
          DJANGO_ALLOWED_HOSTS: ${{ vars.DJANGO_ALLOWED_HOSTS }}
          CSRF_TRUSTED_ORIGINS: ${{ vars.CSRF_TRUSTED_ORIGINS }}
          CORS_ALLOWED_ORIGINS: ${{ vars.CORS_ALLOWED_ORIGINS }}
          AWS_STORAGE_BUCKET_NAME: ${{ vars.AWS_STORAGE_BUCKET_NAME || 'itg-static-assets' }}
          AWS_S3_REGION_NAME: ${{ vars.AWS_S3_REGION_NAME || 'us-west-2' }}
        run: |
          python - <<'PY'
          import json
          import os
          from urllib.parse import urlparse

          template_path = "aws/task-definition.json"
          output_path = "rendered-task-definition.json"
          empty_sentinels = {"__EMPTY__", "__UNSET__", "null", "None"}

          def env_value(name: str, default: str = "") -> str:
              value = os.environ.get(name, default)
              if value is None:
                  return ""
              return "" if value in empty_sentinels else value

          with open(template_path, "r", encoding="utf-8") as f:
              taskdef = json.load(f)

          frontend_url = env_value("FRONTEND_URL").strip()
          api_base_url = env_value("API_BASE_URL").strip()

          csrf_origins = env_value("CSRF_TRUSTED_ORIGINS").strip()
          if not csrf_origins:
              csrf_values = [x for x in [frontend_url, api_base_url] if x]
              csrf_origins = ",".join(csrf_values)

          cors_origins = env_value("CORS_ALLOWED_ORIGINS").strip() or frontend_url

          allowed_hosts = env_value("DJANGO_ALLOWED_HOSTS").strip()
          if not allowed_hosts:
              hosts = []
              parsed = urlparse(api_base_url)
              if parsed.hostname:
                  hosts.append(parsed.hostname)
              hosts.extend([".cloudfront.net", ".elb.amazonaws.com"])
              allowed_hosts = ",".join(dict.fromkeys([h for h in hosts if h]))

          mapping = {
              "__DJANGO_SECRET_KEY__": env_value("DJANGO_SECRET_KEY"),
              "__DJANGO_ALLOWED_HOSTS__": allowed_hosts,
              "__DB_NAME__": env_value("DB_NAME"),
              "__DB_USER__": env_value("DB_USER"),
              "__DB_PASSWORD__": env_value("DB_PASSWORD"),
              "__DB_HOST__": env_value("DB_HOST"),
              "__DB_PORT__": env_value("DB_PORT", "5432"),
              "__REDIS_URL__": env_value("REDIS_URL"),
              "__CSRF_TRUSTED_ORIGINS__": csrf_origins,
              "__CORS_ALLOWED_ORIGINS__": cors_origins,
              "__FRONTEND_URL__": frontend_url,
              "__AWS_STORAGE_BUCKET_NAME__": env_value("AWS_STORAGE_BUCKET_NAME", "itg-static-assets"),
              "__AWS_S3_REGION_NAME__": env_value("AWS_S3_REGION_NAME", "us-west-2"),
              "__DJANGO_SUPERUSER_USERNAME__": env_value("DJANGO_SUPERUSER_USERNAME"),
              "__DJANGO_SUPERUSER_EMAIL__": env_value("DJANGO_SUPERUSER_EMAIL"),
              "__DJANGO_SUPERUSER_PASSWORD__": env_value("DJANGO_SUPERUSER_PASSWORD"),
          }

          container = taskdef["containerDefinitions"][0]
          container["image"] = os.environ["IMAGE_URI"]

          for item in container.get("environment", []):
              value = item.get("value", "")
              if value in mapping:
                  item["value"] = mapping[value]

          # Optional DB_ENGINE override; prod defaults to PostgreSQL if unset.
          db_engine = env_value("DB_ENGINE").strip()
          if db_engine:
              container["environment"].append({"name": "DB_ENGINE", "value": db_engine})

          with open(output_path, "w", encoding="utf-8") as f:
              json.dump(taskdef, f, indent=2)
          PY
          echo "task-definition=rendered-task-definition.json" >> "$GITHUB_OUTPUT"

      - name: Deploy to ECS
        uses: aws-actions/amazon-ecs-deploy-task-definition@v2
        with:
          task-definition: ${{ steps.task-def.outputs.task-definition }}
          service: ${{ env.ECS_SERVICE }}
          cluster: ${{ env.ECS_CLUSTER }}
          wait-for-service-stability: true

      - name: Smoke check deployed health endpoint and CORS
        env:
          FRONTEND_URL: ${{ vars.FRONTEND_URL || 'https://main.d1fekd6ba7zdu.amplifyapp.com' }}
          API_BASE_URL: ${{ vars.VITE_API_BASE_URL }}
        run: |
          set -euo pipefail

          if [ -z "${FRONTEND_URL:-}" ]; then
            echo "FRONTEND_URL is required for smoke checks."
            exit 1
          fi

          if [ -z "${API_BASE_URL:-}" ]; then
            echo "VITE_API_BASE_URL is required for smoke checks."
            exit 1
          fi

          health_url="${API_BASE_URL%/}/health/"
          headers_file="$(mktemp)"
          headers_clean="$(mktemp)"
          body_file="$(mktemp)"

          status_code="$(curl -sS -D "$headers_file" -o "$body_file" \
            -H "Origin: $FRONTEND_URL" \
            "$health_url" \
            -w "%{http_code}")"

          tr -d '\r' < "$headers_file" > "$headers_clean"

          if [ "$status_code" != "200" ]; then
            echo "Health check failed with status $status_code"
            echo "Response headers:"
            cat "$headers_clean"
            echo "Response body:"
            cat "$body_file"
            exit 1
          fi

          cors_origin="$(awk -F': ' 'tolower($1) == "access-control-allow-origin" {print $2; exit}' "$headers_clean")"
          if [ "$cors_origin" != "$FRONTEND_URL" ]; then
            echo "Expected Access-Control-Allow-Origin: $FRONTEND_URL"
            echo "Actual Access-Control-Allow-Origin: ${cors_origin:-<missing>}"
            echo "Response headers:"
            cat "$headers_clean"
            exit 1
          fi

          python - <<'PY' "$body_file"
          import json
          import sys

          path = sys.argv[1]
          with open(path, "r", encoding="utf-8") as f:
              payload = json.load(f)

          if payload.get("status") != "ok":
              raise SystemExit(f"Unexpected health payload: {payload}")
          PY

          echo "Health/CORS smoke check passed for $health_url"
