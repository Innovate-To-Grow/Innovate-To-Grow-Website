import logging
from django.core.cache import cache
from django.core.signing import BadSignature, SignatureExpired, TimestampSigner
from django.views.generic import TemplateView
from rest_framework import status
from rest_framework.exceptions import PermissionDenied, ValidationError
from rest_framework.generics import CreateAPIView, ListAPIView, RetrieveAPIView
from rest_framework.permissions import AllowAny, IsAdminUser
from rest_framework.response import Response
from rest_framework.views import APIView

from ..models import FooterContent, FormSubmission, HomePage, Menu, Page, UniformForm
from ..serializers import (
    FooterContentSerializer,
    FormSubmissionCreateSerializer,
    FormSubmissionListSerializer,
    HomePageSerializer,
    MenuSerializer,
    PageSerializer,
    UniformFormSerializer,
)

logger = logging.getLogger(__name__)


class PreviewPopupView(TemplateView):
    """
    Render the popup preview page for live editing.
    """

    template_name = "pages/preview_popup.html"


class ComponentPreviewView(TemplateView):
    """
    Render the component preview page for live editing PageComponents.
    """

    template_name = "pages/component_preview.html"


class ValidatePreviewTokenView(APIView):
    """
    Validate a preview token generated by the admin site.
    """

    permission_classes = [AllowAny]

    def post(self, request, *args, **kwargs):
        token = request.data.get("token")
        object_id = request.data.get("objectId")

        if not token:
            logger.warning("Preview token validation failed: missing token (objectId=%s)", object_id)
            return Response({"valid": False, "detail": "Token is required"}, status=status.HTTP_400_BAD_REQUEST)

        signer = TimestampSigner()
        try:
            # Token is valid for 1 hour (3600 seconds)
            unsigned_value = signer.unsign(token, max_age=3600)

            # If object_id is provided, verify it matches the signed value
            # Note: We compare strings because unsigned_value is a string and object_id might be UUID or string
            if object_id and str(unsigned_value) != str(object_id) and str(unsigned_value) != "preview":
                # "preview" is legacy/fallback value
                logger.warning(
                    "Preview token validation failed: token mismatch (signed=%s objectId=%s)",
                    unsigned_value,
                    object_id,
                )
                return Response({"valid": False, "detail": "Token mismatch"}, status=status.HTTP_400_BAD_REQUEST)

            return Response({"valid": True})
        except (BadSignature, SignatureExpired):
            logger.warning("Preview token validation failed: invalid/expired token (objectId=%s)", object_id)
            return Response({"valid": False, "detail": "Invalid or expired token"}, status=status.HTTP_400_BAD_REQUEST)


class PreviewDataView(APIView):
    """
    Shared data store for live preview.
    Admin JS POSTs component data; preview page GETs it by sessionId.
    Uses Django cache so no DB writes are needed.
    """

    permission_classes = [AllowAny]

    def get(self, request, *args, **kwargs):
        session_id = request.query_params.get("sessionId")
        if not session_id:
            return Response({"detail": "sessionId required"}, status=status.HTTP_400_BAD_REQUEST)

        cache_key = f"preview-data:{session_id}"
        data = cache.get(cache_key)
        if data is None:
            return Response({"components": [], "timestamp": 0})
        return Response(data)

    def post(self, request, *args, **kwargs):
        session_id = request.data.get("sessionId")
        if not session_id:
            return Response({"detail": "sessionId required"}, status=status.HTTP_400_BAD_REQUEST)

        import time

        payload = {
            "components": request.data.get("components", []),
            "timestamp": time.time(),
        }
        cache_key = f"preview-data:{session_id}"
        cache.set(cache_key, payload, timeout=3600)
        return Response({"ok": True})


class HomePageAPIView(APIView):
    """
    Retrieve the currently active home page with caching.
    Cache timeout: 5 minutes (300 seconds)
    """

    permission_classes = [AllowAny]

    def get(self, request, *args, **kwargs):
        # Try to get from cache
        cache_key = "homepage:active"
        cached_data = cache.get(cache_key)

        if cached_data is not None:
            return Response(cached_data)

        # Cache miss - fetch from database
        home_page = HomePage.get_active()
        if not home_page:
            return Response(
                {"detail": "No active home page found."},
                status=status.HTTP_404_NOT_FOUND,
            )

        serializer = HomePageSerializer(home_page)
        data = serializer.data

        # Cache for 5 minutes
        cache.set(cache_key, data, timeout=300)

        return Response(data)


class PageListAPIView(ListAPIView):
    """
    List published pages (for menu editor dropdown and public listing).
    """

    serializer_class = PageSerializer
    permission_classes = [AllowAny]

    def get_queryset(self):
        return Page.objects.filter(status="published").order_by("title")

    def list(self, request, *args, **kwargs):
        queryset = self.get_queryset()
        # Return simplified list for menu editor
        pages = [{"slug": p.slug, "title": p.title} for p in queryset]
        return Response({"pages": pages})


class PageRetrieveAPIView(RetrieveAPIView):
    """
    Retrieve a published page by slug, with caching.
    Cache timeout: 5 minutes (300 seconds)
    """

    serializer_class = PageSerializer
    lookup_field = "slug"
    lookup_url_kwarg = "slug"
    permission_classes = [AllowAny]

    def get_queryset(self):
        return Page.objects.filter(status="published")

    def retrieve(self, request, *args, **kwargs):
        slug = self.kwargs.get("slug")
        cache_key = f"page:slug:{slug}"

        # Try to get from cache
        cached_data = cache.get(cache_key)
        if cached_data is not None:
            return Response(cached_data)

        # Cache miss - fetch from database
        page = Page.get_published_by_slug(slug)
        if page is None:
            from rest_framework.exceptions import NotFound

            raise NotFound("Page not found.")

        serializer = self.get_serializer(page)
        data = serializer.data

        # Cache for 5 minutes
        cache.set(cache_key, data, timeout=300)

        return Response(data)


class UniformFormRetrieveAPIView(RetrieveAPIView):
    """
    Retrieve a form by slug for rendering.

    Returns form configuration including fields, settings, and display options.
    Only returns active and published forms.
    """

    queryset = UniformForm.objects.filter(is_active=True, published=True)
    serializer_class = UniformFormSerializer
    lookup_field = "slug"
    permission_classes = [AllowAny]


class FormSubmissionCreateAPIView(CreateAPIView):
    """
    Create a form submission.

    Validates submission data against form field definitions and stores
    the submission with metadata (IP address, user agent, etc.).
    """

    serializer_class = FormSubmissionCreateSerializer
    permission_classes = [AllowAny]

    def perform_create(self, serializer):
        """Additional validation and submission limit checking."""
        form = serializer.validated_data["form"]

        # Check if form is active and published
        if not form.is_active or not form.published:
            raise ValidationError("This form is not accepting submissions.")

        # Check login requirement
        if form.login_required and not self.request.user.is_authenticated:
            raise PermissionDenied("You must be logged in to submit this form.")

        # Check submission limits for authenticated users
        if self.request.user.is_authenticated and form.max_submissions_per_user > 0:
            user_submission_count = FormSubmission.objects.filter(form=form, user=self.request.user).count()

            if user_submission_count >= form.max_submissions_per_user:
                raise ValidationError(
                    f"You have reached the maximum number of submissions ({form.max_submissions_per_user}) for this form."
                )

        # Create the submission
        serializer.save()


class FormSubmissionListAPIView(ListAPIView):
    """
    List submissions for a specific form (admin only).

    Returns all submissions for the specified form, ordered by submission date.
    """

    serializer_class = FormSubmissionListSerializer
    permission_classes = [IsAdminUser]

    def get_queryset(self):
        form_slug = self.kwargs["form_slug"]
        return FormSubmission.objects.filter(form__slug=form_slug)


class LayoutAPIView(APIView):
    """
    Unified endpoint for layout data (menus and footer) with caching.
    Cache timeout: 10 minutes (600 seconds) - layout changes infrequently
    """

    permission_classes = [AllowAny]

    def get(self, request, *args, **kwargs):
        cache_key = "layout:data"

        # Try to get from cache
        cached_data = cache.get(cache_key)
        if cached_data is not None:
            return Response(cached_data)

        # Cache miss - fetch from database
        # 1. Get menus
        menus = Menu.objects.all().order_by("display_name")
        menu_serializer = MenuSerializer(menus, many=True)

        # 2. Get active footer
        footer = FooterContent.get_active()
        footer_data = None
        if footer:
            footer_serializer = FooterContentSerializer(footer)
            footer_data = footer_serializer.data

        data = {"menus": menu_serializer.data, "footer": footer_data}

        # Cache for 10 minutes (layout changes infrequently)
        cache.set(cache_key, data, timeout=600)

        return Response(data)
