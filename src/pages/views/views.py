import logging

from django.core.cache import cache
from django.core.signing import BadSignature, SignatureExpired, TimestampSigner
from django.views.generic import TemplateView
from rest_framework import status
from rest_framework.generics import ListAPIView, RetrieveAPIView
from rest_framework.permissions import AllowAny
from rest_framework.response import Response
from rest_framework.views import APIView

from ..models import FooterContent, HomePage, Menu, Page
from ..serializers import (
    FooterContentSerializer,
    HomePageSerializer,
    MenuSerializer,
    PageSerializer,
)

logger = logging.getLogger(__name__)


class PreviewPopupView(TemplateView):
    """Render the popup preview page for live editing."""

    template_name = "pages/preview_popup.html"


class ComponentPreviewView(TemplateView):
    """Render the component preview page for live editing."""

    template_name = "pages/component_preview.html"


class ValidatePreviewTokenView(APIView):
    """Validate a preview token generated by the admin site."""

    permission_classes = [AllowAny]

    def post(self, request, *args, **kwargs):
        token = request.data.get("token")
        object_id = request.data.get("objectId")

        if not token:
            logger.warning("Preview token validation failed: missing token (objectId=%s)", object_id)
            return Response({"valid": False, "detail": "Token is required"}, status=status.HTTP_400_BAD_REQUEST)

        signer = TimestampSigner()
        try:
            unsigned_value = signer.unsign(token, max_age=3600)

            if object_id and str(unsigned_value) != str(object_id) and str(unsigned_value) != "preview":
                logger.warning(
                    "Preview token validation failed: token mismatch (signed=%s objectId=%s)",
                    unsigned_value,
                    object_id,
                )
                return Response({"valid": False, "detail": "Token mismatch"}, status=status.HTTP_400_BAD_REQUEST)

            return Response({"valid": True})
        except (BadSignature, SignatureExpired):
            logger.warning("Preview token validation failed: invalid/expired token (objectId=%s)", object_id)
            return Response({"valid": False, "detail": "Invalid or expired token"}, status=status.HTTP_400_BAD_REQUEST)


class PreviewDataView(APIView):
    """
    Shared data store for live preview.
    Admin JS POSTs page data; preview page GETs it by sessionId.
    Uses Django cache so no DB writes are needed.
    """

    permission_classes = [AllowAny]

    def get(self, request, *args, **kwargs):
        session_id = request.query_params.get("sessionId")
        if not session_id:
            return Response({"detail": "sessionId required"}, status=status.HTTP_400_BAD_REQUEST)

        cache_key = f"preview-data:{session_id}"
        data = cache.get(cache_key)
        if data is None:
            return Response({"html": "", "css": "", "timestamp": 0})
        return Response(data)

    def post(self, request, *args, **kwargs):
        session_id = request.data.get("sessionId")
        if not session_id:
            return Response({"detail": "sessionId required"}, status=status.HTTP_400_BAD_REQUEST)

        import time

        payload = {
            "html": request.data.get("html", ""),
            "css": request.data.get("css", ""),
            "timestamp": time.time(),
        }
        cache_key = f"preview-data:{session_id}"
        cache.set(cache_key, payload, timeout=3600)
        return Response({"ok": True})


class HomePageAPIView(APIView):
    """Retrieve the currently active home page with caching."""

    permission_classes = [AllowAny]

    def get(self, request, *args, **kwargs):
        cache_key = "homepage:active"
        cached_data = cache.get(cache_key)

        if cached_data is not None:
            return Response(cached_data)

        home_page = HomePage.get_active()
        if not home_page:
            return Response(
                {"detail": "No active home page found."},
                status=status.HTTP_404_NOT_FOUND,
            )

        serializer = HomePageSerializer(home_page)
        data = serializer.data

        cache.set(cache_key, data, timeout=300)

        return Response(data)


class PageListAPIView(ListAPIView):
    """List published pages (for menu editor dropdown and public listing)."""

    serializer_class = PageSerializer
    permission_classes = [AllowAny]

    def get_queryset(self):
        return Page.objects.filter(status="published").order_by("title")

    def list(self, request, *args, **kwargs):
        queryset = self.get_queryset()
        pages = [{"slug": p.slug, "title": p.title} for p in queryset]
        return Response({"pages": pages})


class PageRetrieveAPIView(RetrieveAPIView):
    """Retrieve a published page by slug, with caching."""

    serializer_class = PageSerializer
    lookup_field = "slug"
    lookup_url_kwarg = "slug"
    permission_classes = [AllowAny]

    def get_queryset(self):
        return Page.objects.filter(status="published")

    def retrieve(self, request, *args, **kwargs):
        slug = self.kwargs.get("slug")
        cache_key = f"page:slug:{slug}"

        cached_data = cache.get(cache_key)
        if cached_data is not None:
            return Response(cached_data)

        page = Page.get_published_by_slug(slug)
        if page is None:
            from rest_framework.exceptions import NotFound

            raise NotFound("Page not found.")

        serializer = self.get_serializer(page)
        data = serializer.data

        cache.set(cache_key, data, timeout=300)

        return Response(data)


class LayoutAPIView(APIView):
    """Unified endpoint for layout data (menus and footer) with caching."""

    permission_classes = [AllowAny]

    def get(self, request, *args, **kwargs):
        cache_key = "layout:data"

        cached_data = cache.get(cache_key)
        if cached_data is not None:
            return Response(cached_data)

        menus = Menu.objects.all().order_by("display_name")
        menu_serializer = MenuSerializer(menus, many=True)

        footer = FooterContent.get_active()
        footer_data = None
        if footer:
            footer_serializer = FooterContentSerializer(footer)
            footer_data = footer_serializer.data

        data = {"menus": menu_serializer.data, "footer": footer_data}

        cache.set(cache_key, data, timeout=600)

        return Response(data)
